# TEAM MODEL — финальная спецификация (без БД/ТГ/фронта)

Это чистая **модель** для:
- хранения состояния игроков (глобал + зал)
- генерации команд (по эффективному рейтингу + синергии/доминации/ролям)
- обучения после матча (результат матча — главный сигнал)
- учета сегментов и режима «на жопу»
- быстрого фидбека (влияет на рейтинг)
- расширенного фидбека (НЕ влияет на рейтинг; только сыгранность/доминация/роль)
- гостей (быстрее учатся, стартуют ниже среднего)

## 1) Сущности и состояния

### PlayerState
У каждого игрока храним:
- `global_rating` — глобальный рейтинг (всегда обновляется после каждого матча)
- `venue_ratings[venue]` — рейтинг в конкретном зале (обновляется **только** если матч был в этом зале)
- `synergy[(p,q,venue)]` — сыгранность пары (симметричная)
- `domination[(p,q,venue)]` — доминация p над q (направленная)
- `role_profile[p]` — профиль ролей (атака/оборона и т.п.)
- guest поля: `is_guest`, `guest_matches`

Изначально:
- глобал = 1000
- зал = 1000 (если игрок ещё не играл в этом зале)
- синергии/доминации/роли = 0

## 2) Рейтинг для генерации команд

**Важно:** 60/40 используется ТОЛЬКО для генерации команд (Reff), а не для обновления.

Для матча в зале `V`:

- `R_global(p) = global_rating`
- `R_venue(p,V) = venue_ratings[V]` (или 1000 если нет)
- **эффективный рейтинг для генерации:**

  `R_eff(p,V) = wV * R_venue(p,V) + wG * R_global(p)`

где по умолчанию:
- `wV = 0.6` (зал важнее)
- `wG = 0.4`

Дальше teamgen использует:
- баланс по сумме `R_eff`
- поправки за синергию/доминации/роли как вторичные штрафы/бонусы (они НЕ «заменяют» рейтинг)

## 3) Матч и сегменты

Матч состоит из сегментов, сегменты упорядочены по времени.

Каждый сегмент имеет:
- `goal_diff = goals_A - goals_B` (внутри сегмента)
- `weight` (пример: 0.3 / 0.6 / 1.0)
- флаг `butt_game` («на жопу»)

Мультипликаторы «на жопу»:
- для результата сегмента: `M_seg = 1.375`
- для событий в сегменте: `M_evt = 1.75`

## 4) Главный импульс от результата матча

Считаем **взвешенную разницу**:

`WD = Σ (goal_diff_seg * weight_seg * (M_seg if butt_game else 1))`

Дальше переводим WD в импульс (примерная шкала):
- |WD|≈1 → 60
- |WD|≈2 → 120
- |WD|≈3 → 180
- |WD|>=4 → 220 (потолок)

Знак импульса:
- если WD>0 → команда A получает +impulse, B получает −impulse
- если WD<0 → наоборот

## 5) Игровые события (гол/ассист/деф)

**Текущая логика проекта:** события **сглаживают** (добавляют/убирают) персональный итог,
а не обязаны сохранять сумму по команде.

Для события в сегменте:

`evt = base_value(event_type) * weight_seg * (M_evt if butt_game else 1)`

Базовые значения (по умолчанию):
- гол: 10
- ассист: 6
- деф-действие: 6

Дальше событие добавляется к персональному raw_delta:
- победителю помогает ещё чуть больше закрепиться
- проигравшему может сильно «смягчить» минус, если он реально тащил

## 6) Быстрый фидбек и расширенный

### Quick feedback (влияет на рейтинг)
Состав:
- anchors: MVP и «привёз» (step-based)
- pairwise сравнения (±4 за сравнение, максимум около ±12)
- fan-вопросы (очень слабый ±2)

### Expanded feedback (НЕ влияет на рейтинг)
- НЕ меняет рейтинг вообще
- меняет только:
  - синергии
  - доминации
  - роли/тенденции
- tier-листы отсутствуют (убраны)

## 7) Anchors: step-based (MVP / привёз)

Пусть:
- `m` = сколько голосов MVP
- `a` = сколько голосов «привёз»
- `net = m - a`

Шаги:
- 1 → 15
- 2–4 → 2,2,2
- 5+ → 1,1,1...

Тогда:
- если net>0 → `+sum(steps[1..net])`
- если net<0 → `-sum(steps[1..|net|])`
- если net=0 → 0

**Принцип:** «привёз» отменяет *шаги*, а не «снимает 15 сразу».

## 8) Anti-boost для топов

Если игрок выше среднего рейтинга матча и он получает **плюс**, то плюс демпфируется:

Пусть:
- `avg = средний рейтинг игроков матча (в rating-space)`
- `r = текущий рейтинг игрока (в rating-space)`
- `x = r - avg`

Если delta>0 и x>0:
- 0..100 → *0.9
- 100..200 → *0.75
- 200+ → *0.6

Минусы НЕ демпфируются.

## 9) Кап на матч

Один общий кап на матч, зависит от среднего рейтинга матча:

`cap = avg_match_rating * cap_pct` (пример cap_pct=0.08 → при avg=1000 cap=80)

Порядок:
1) собираем `raw_delta` (результат + события + quick feedback)
2) применяем anti-boost (только к положительным)
3) clamp: `final_delta = clamp(raw_delta, -cap, +cap)`
4) **после clamp рейтинг больше не трогаем**

## 10) Обновление рейтинга (ВАЖНО)

После матча в зале V:

- `global_rating += final_delta`
- `venue_ratings[V] += final_delta`

То есть **одно и то же** изменение идёт и в глобал, и в зал (если матч был в этом зале).
В других залах venue-рейтинг не меняется.

## 11) Гости

- стартуют чуть ниже среднего
- учатся быстрее первые 1–2 матча (множитель к raw_delta)
- расширенный фидбек помогает их калибровать через «кто на одном уровне»

После ~3 матчей становятся обычными.

---
